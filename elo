#!/usr/bin/env python3

import sys, csv, argparse
import statistics as stat
from collections import defaultdict as dd

# This value seems fairly standard if a global k-factor is to be used
global_k = 32

description = "elo is an implementation of the Elo rating system for zero-sum games.\n\
               https://en.wikipedia.org/wiki/Elo_rating_system"

csv_help = "One or more CSV files, each representing a separate league.\
            Each row represents a single match, with the winner in the first column\
            and the loser in the second column.\
            Entries in other columns will be ignored and may therefore contain comments."

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("file", nargs="+", help=csv_help)
    parser.add_argument("-s", "--show_history", action="store_true",
                        help="Show all ratings updates.")
    args = parser.parse_args()
    files = args.file
    show_history = args.show_history

    for file in files: # For each input csv file (argv[0] is this program)
        print(file+"\n"+"-"*15)

        players = dd() # Player dictionary

        # Default factory
        def df():
            if players == {}:
                return [1000] # The first player starts at 1000
            # Every other new player starts at the average ranking
            return [stat.mean([rankings[-1] for rankings in players.values()])]

        players.default_factory = df # Hook up the player dict to the default factory

        with open(file) as league:
            reader = csv.reader(league)
            for match in reader: # Iterate match-by-match
                # Winner should be in the first column, loser in the second
                winner = match[0]
                loser = match[1]

                # Most recent ratings
                winner_rating = players[winner][-1]
                loser_rating = players[loser][-1]

                # Currently k-factor is global, but could instead be based on
                # rating and number of matches played
                winner_k = global_k
                loser_k = global_k

                # Expectation
                expected_outcome = 1 / (1 + 10**((loser_rating - winner_rating)/400))

                # Update ratings
                players[winner].append(winner_rating + winner_k*(1 - expected_outcome))
                players[loser].append(loser_rating + loser_k*(expected_outcome - 1))

            # Print current ratings in descending order
            for player, ratings in sorted(players.items(), key=lambda x: x[1][-1], reverse=True):
                if show_history:
                    print(player, ratings)
                else:
                    print(player, ratings[-1])

        print("="*20+"\n")
